(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{555:function(v,e,t){"use strict";t.r(e);var _=t(29),r=Object(_.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[v._v("#")]),v._v(" 缓存穿透")]),v._v(" "),t("h4",{attrs:{id:"什么是缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存穿透"}},[v._v("#")]),v._v(" 什么是缓存穿透？")]),v._v(" "),t("p",[v._v("**缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。**举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。")]),v._v(" "),t("h4",{attrs:{id:"解决办法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[v._v("#")]),v._v(" 解决办法")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("缓存无效 key")])]),v._v(" "),t("li",[t("p",[v._v("布隆过滤器")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),t("h4",{attrs:{id:"什么是缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存雪崩"}},[v._v("#")]),v._v(" 什么是缓存雪崩?")]),v._v(" "),t("p",[t("strong",[v._v("缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。")]),v._v(" 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。")]),v._v(" "),t("h4",{attrs:{id:"解决办法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决办法-2"}},[v._v("#")]),v._v(" 解决办法")]),v._v(" "),t("ol",[t("li",[v._v("设置不同的失效时间比如随机设置缓存的失效时间。")]),v._v(" "),t("li",[v._v("缓存永不失效")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[v._v("#")]),v._v(" 缓存击穿")]),v._v(" "),t("h4",{attrs:{id:"什么是缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存击穿"}},[v._v("#")]),v._v(" 什么是缓存击穿?")]),v._v(" "),t("p",[v._v("简单来说，"),t("strong",[v._v("缓存击穿是指一个 key 非常热点")]),v._v("。在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就好像堤坝突然破了一个口，大量洪水汹涌而入。当发生缓存击穿的时候，数据库的查询压力会倍增，导致大量的请求阻塞。")]),v._v(" "),t("h4",{attrs:{id:"解决办法-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决办法-3"}},[v._v("#")]),v._v(" 解决办法")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("不设置key 设置失效时间  ，"),t("strong",[v._v("如果数据需要更新的话")]),v._v("，我们可以"),t("strong",[v._v("后台开启一个异步线程，发现过期的 key 直接重写缓存")]),v._v("即可，这种解决方案只适用于不要求数据严格一致性的情况，如果要严格保证数据一致的话，可以用互斥锁")])]),v._v(" "),t("li",[t("p",[v._v("互斥锁，"),t("strong",[v._v("当 key 失效的时候，让一个线程读取数据并构建到缓存中，其他线程就先等待，直到缓存构建完后重新读取缓存")]),v._v("即可")]),v._v(" "),t("blockquote",[t("p",[v._v("如果是单机系统，用 JDK 本身的同步工具 Synchronized 或 ReentrantLock 就可以实现，但一般来说，都达到防止缓存击穿的流量了谁还搞什么单机系统，肯定是分布式高大上点啊，这种情况我们就可以用分布式锁来做互斥效果。")])])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"redis过期删除策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis过期删除策略"}},[v._v("#")]),v._v(" Redis过期删除策略")]),v._v(" "),t("p",[v._v("如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？")]),v._v(" "),t("p",[v._v("常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("惰性删除")]),v._v(" ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。")]),v._v(" "),t("li",[t("strong",[v._v("定期删除")]),v._v(" ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。")])]),v._v(" "),t("p",[v._v("定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 "),t("strong",[v._v("定期删除+惰性/懒汉式删除")]),v._v(" 。")]),v._v(" "),t("p",[v._v("但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。")]),v._v(" "),t("p",[v._v("怎么解决这个问题呢？答案就是："),t("strong",[v._v("Redis 内存淘汰机制。")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"redis内存淘汰机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis内存淘汰机制"}},[v._v("#")]),v._v(" Redis内存淘汰机制")]),v._v(" "),t("p",[v._v("Redis 提供 6 种数据淘汰策略：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("volatile-lru（least recently used）")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰")]),v._v(" "),t("li",[t("strong",[v._v("volatile-ttl")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰")]),v._v(" "),t("li",[t("strong",[v._v("volatile-random")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰")]),v._v(" "),t("li",[t("strong",[v._v("allkeys-lru（least recently used）")]),v._v("：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）")]),v._v(" "),t("li",[t("strong",[v._v("allkeys-random")]),v._v("：从数据集（server.db[i].dict）中任意选择数据淘汰")]),v._v(" "),t("li",[t("strong",[v._v("no-eviction")]),v._v("：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！")])]),v._v(" "),t("p",[v._v("4.0 版本后增加以下两种：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("volatile-lfu（least frequently used）")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰")]),v._v(" "),t("li",[t("strong",[v._v("allkeys-lfu（least frequently used）")]),v._v("：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"数据的一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据的一致性"}},[v._v("#")]),v._v(" 数据的一致性")]),v._v(" "),t("p",[v._v("细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。")]),v._v(" "),t("p",[v._v("下面单独对 "),t("strong",[v._v("Cache Aside Pattern（旁路缓存模式）")]),v._v(" 来聊聊。")]),v._v(" "),t("p",[v._v("Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。")]),v._v(" "),t("p",[v._v("如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("缓存失效时间变短（不推荐，治标不治本）")]),v._v(" ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。")]),v._v(" "),t("li",[t("strong",[v._v("增加 cache 更新重试机制（常用）")]),v._v("： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可")])])])}),[],!1,null,null,null);e.default=r.exports}}]);